#ifndef MYLIST
#define MYLIST

#include <algorithm>
#include <list>
#include <memory>

////////////////////////////////////////////////////////////////////
/////////////////////////// УЗЕЛ СПИСКА ////////////////////////////
////////////////////////////////////////////////////////////////////
template <typename Y>
struct Node {
    Node(const Y& value, Node* prev = nullptr, Node* next = nullptr)
    : value(value), prev(prev), next(next) {}

    Y value; // копия переданного элемента списка
    Node *prev; // ссылка на предыдущий элемент списка
    Node *next; // ссылка на последующий элемент списка
};

////////////////////////////////////////////////////////////////////
///////////////////////// ОПИСАНИЕ СПИСКА //////////////////////////
////////////////////////////////////////////////////////////////////
template <class T>
class MyList {

    Node<T>* first; // ссылка на первый элемент списка
    Node<T>* last; // ссылка на последний элемент списка
    size_t size; // количество элементов списка

public:

    ////////////////////////////////////////////////////////////////
    /////////////////// ПОЛЬЗОВАТЕЛЬСКИЙ ИТЕРАТОР //////////////////
    ////////////////////////////////////////////////////////////////

    struct MyIterator {

        MyIterator(Node<T>* ptr) : mPtr(ptr) {}

        T& operator*() const { return mPtr->value; }
        T* operator->() const { return mPtr; }

        // префиксный итератор сложения
        MyIterator& operator++() {
        mPtr = mPtr->next;
        return *this;
        }

        //постфиксный итератор сложения
        MyIterator operator++(int) {
        MyIterator temp = *this;
        mPtr = mPtr->next;
        return temp;
        }

        // префиксный итератор вычитания
        MyIterator& operator--() {
        mPtr = mPtr->prev;
        return *this;
        }

        //постфиксный итератор вычитания
        MyIterator operator--(int) {
        MyIterator temp = *this;
        mPtr = mPtr->prev;
        return temp;
        }

        friend bool operator==(const MyIterator& lhs, const MyIterator& rhs) { return lhs.mPtr == rhs.mPtr; }
        friend bool operator!=(const MyIterator& lhs, const MyIterator& rhs) { return !(lhs == rhs); }

    private:
        Node<T>* mPtr;

    };



    //////////////////////////////////////////////////////////////
    /////////////////////// КОНСТРУКТОРЫ /////////////////////////
    //////////////////////////////////////////////////////////////

    // конструктор по умолчанию, создающий пустой контейнер без элементов
    // указателям на первый и последний узлы списка присваиваем nullptr чтобы было ясно что узлов нет
    explicit MyList() : first(nullptr), last(nullptr), size(0) {};

    // конструктор с числом count копий элемента имеющего значение value
    MyList(size_t count, const T& value) : MyList(){ // делегируем создание пустого списка конструктору по умолчанию
        this->assign(count, value);
    }

    // TODO:
    // конструктор копирования

    // конструктор перемещения

    // конструктор для создания контейнера с содержимым списка инициализации init



    ////////////////////////////////////////////////////////
    ///////////// ДЕСТРУКТОР, ОЧИЩЕНИЕ ПАМЯТИ //////////////
    ////////////////////////////////////////////////////////

    ~MyList() {
        clearList(); // деструктор списка вызывает функцию очищения списка
        delete first; // удаляем указатель на первый элемент списка
        delete last; // удаляем указатель на последний элемент списка
    }

    void clearList() { // функция очищения списка
        while (first) { // пока указатель на первый элемент списка на что-то указывает, значит список еще не пуст
            popFront(); // пока список еще не пуст, в цикле будет вызываться функция удаления первого элемента списка
        }
    }


    ////////////////////////////////////////////////////////
    /////////////////// ОПЕРАТОРЫ СПИСКА ///////////////////
    ////////////////////////////////////////////////////////

    // оператор присваивания копированием
    MyList& operator= (const MyList& other) {
        clearList();
        size = other.size;
        for (const T& value : other) {
            pushBack(value);
        }
        return *this;
    }

    // оператор присваивания перемещением
    MyList& operator= (MyList&& other) {
        clearList();
        size = other.size;
    }

    // замена текущего содержимого содержимым списка инициализации
    MyList& operator= (std::initializer_list<T> other) {
        clearList();
        size = other.size;
    }

    ////////////////////////////////////////////////////////
    //////// МЕТОДЫ ДОБАВЛЕНИЯ И УДАЛЕНИЯ ЭЛЕМЕНТОВ ////////
    ////////////////////////////////////////////////////////

    // добавление элемента в конец списка
    void pushBack(const T& value) {
        // выделяем память под новый узел - элемент списка
        // конструктору узла передаем сам элемент, адрес последнего элемента указателю на предыдущий узел,
        // и nullptr указателю на следующий узел, так как мы добавляем элемент в конец списка
        Node<T>* newNode = new Node<T>(value, last, nullptr);
        if (last) { // проверяем, существует ли последний узел - адресует ли на что-то указатель на последний узел
            last->next = newNode; // если он существует, его указателю на следующий элемент присваиваем адрес нового узла
        } else { // если последнего узла не существует, то делаем вывод, что у нас пустой список
            first = newNode; // присваиваем указателю на первый элемент списка адрес нового узла, который будет первым в списке
        }
        last = newNode; // присваиваем указателю на последний элемент адрес нового узла, так как он теперь и есть последний
        size++; // увеличиваем счетчик узлов списка на 1
    }

    // добавление элемента в начало списка
    void pushFront(const T& value) {
        // выделяем память под новый узел - элемент списка
        // конструктору узла передаем сам элемент, адрес первого элемента указателю на последующий узел,
        // и nullptr указателю на предыдущий узел, так как мы добавляем элемент в начало списка
        Node<T>* newNode = new Node<T>(value, nullptr, first);
        if (first) { // проверяем, существует ли первый узел - адресует ли на что-то указатель на первый узел
            first->prev = newNode; // если он существует, его указателю на предыдущее значение присваиваем адрес нового узла
        } else { // если первого узла не существует, делаем вывод, что список пуст
            // если список пуст, то новый первый элемент будет и последним, присваиваем указателю на последний узел
            // адрес нового узла
            last = newNode;
        }
        first = newNode; // присваиваем указателю на первый узел адрес нового первого узла
        size++; // увеличиваем счетчик узлов списка на 1
    }

    // удаление последнего элемента списка
    void popBack() {
        if (last) { // проверяем, существует ли последний узел - то есть не пустой ли у нас список
            // если список не пустой, то удаление его последнего элемента имеет смысл и можно продолжать работу функции
            Node<T>* temp = last; // создаем временный указатель на последний узел списка
            last = last->prev; // присваиваем указателю на последний узел адрес предпоследнего узла
            // после удаления последнего узла списка, предпоследний узел будет считаться новым последним
            // проверим, существует ли этот предпоследний узел
            if (last) { // если этот узел существует, ...
                last->next = nullptr; // ...удаляем адрес старого последнего узла из указателя нового последнего узла
            } else { // если этого узла не существует, делаем вывод, что в списке лежал только один узел
                // поскольку мы его удаляем, список становится пустым после удаления последнего элемента
                first = nullptr; // указателю на первый узел списка присваиваем пустой адрес, так как после удаления список пуст
            }
            delete temp; // удаляем последний узел, который до этого момента лежал во временном указателе temp
            size--; // уменьшаем счетчик количества узлов на 1
        }
    }

    // удаление первого элемента списка
    void popFront() {
        if (first) { // проверяем, существует ли первый узел, то есть не пустой ли у нас список
            // если список не пустой, то удаление его первого элемента имеет смысл и можно продолжать работу функции
            Node<T>* temp = first; // создаем временный указатель на первый узел списка
            first = first->next; // присваиваем указателю на первый узел списка адрес второго узла списка
            // после удаления первого узла списка, второму узлу предстоит стать новым первым узлом
            // проверим, существует ли второй узел у нашего списка
            if (first) { // если второй узел у списка есть, ...
                first->prev = nullptr; // ... указателю на предыдущий элемент у второго узла присваиваем пустой адрес
            } else { // если второго узла у списка нет, ...
                // ... после удаления первого и единственного узла списка, наш список станет пустым
                last = nullptr; // поэтому мы присваиваем пустой адрес указателю на последний элемент списка
            }
            delete temp; // удаляем из памяти первый элемент списка, который до этого лежал по временному указателю temp
            size--; // уменьшаем счетчик элементов списка на 1
        }
    }

    // функция заполнения списка count количеством копий значения value
    void assign(size_t count, const T& value) {
        clearList(); // предварительное очищение списка
        for (size_t i = 0; i < count; i++) { // заполнение пустого списка копиями value в цикле
            pushBack(value);
        }
    }


    //////////////////////////////////////////////////
    ////////////// ВОЗВРАЩЕНИЯ ЗНАЧЕНИЙ //////////////
    //////////////////////////////////////////////////

    //доступ к первому и последнему элементов списка
    T& front() const { return first->value; }
    T& back() const { return last->value; }

    // получения адресов первого и последнего элементов списка
    MyIterator begin() const { return MyIterator(first); }
    MyIterator end() const { return MyIterator(last)++; }

    bool empty() const {
        return size == 0;
    }

    size_t getSize() const {
        return size;
    }

};


#endif
